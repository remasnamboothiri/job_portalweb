{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interview - {{ interview.job_position.title|default:"Job Position" }}</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ¤–</text></svg>">

    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            box-sizing: border-box;
        }
        
        body {
            margin: 0 !important;
            padding: 0 !important;
            background: #202124 !important;
            color: white !important;
            font-family: 'Google Sans', sans-serif !important;
            overflow: hidden !important;
            width: 100vw !important;
            height: 100vh !important;
        }
        
        html {
            width: 100% !important;
            height: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        .interview-progress {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.1);
            z-index: 1000;
        }
        
        .interview-progress-bar {
            height: 100%;
            background: #34a853;
            transition: width 0.3s ease;
        }
        
        .interview-stats {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            z-index: 1000;
        }
        
        .stat-item {
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #34a853;
        }
        
        .stat-label {
            font-size: 12px;
            color: #9aa0a6;
        }
        
        .meet-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #202124;
        }
        
        .video-grid {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            padding: 20px;
            max-height: 70vh;
        }
        
        .video-participant {
            background: #303134;
            border-radius: 12px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }
        
        .ai-avatar {
            font-size: 80px;
            animation: pulse 2s infinite;
        }
        
        .participant-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }
        
        .participant-name {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .subtitle-overlay {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 80%;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .subtitle-overlay.show {
            opacity: 1;
        }
        
        .subtitle-text {
            font-size: 16px;
            line-height: 1.4;
        }
        
        .meet-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            z-index: 1000;
        }
        
        .control-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            background: #5f6368;
            color: white;
        }
        
        .control-btn.mic-active {
            background: #34a853;
        }
        
        .control-btn.mic-muted {
            background: #34a853;
        }
        
        .end-btn {
            background: #ea4335;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
        }
        
        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .completion-modal.show {
            display: flex;
        }
        
        .modal-content {
            background: #303134;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 500px;
        }
        
        .btn-primary {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @media (max-width: 768px) {
            .video-grid {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .interview-stats {
                top: 10px;
                right: 10px;
                gap: 10px;
            }
            
            .stat-item {
                padding: 6px 12px;
            }
            
            .stat-value {
                font-size: 16px;
            }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <!-- Interview Progress Bar -->
    <div class="interview-progress">
        <div class="interview-progress-bar" id="progressBar" style="width: 12.5%;"></div>
    </div>

    <!-- Interview Stats -->
    <div class="interview-stats">
        <div class="stat-item">
            <div class="stat-value" id="questionCounter">1/8</div>
            <div class="stat-label">Questions</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timer">{{ interview.interview_duration_minutes|default:"15" }}:00</div>
            <div class="stat-label">Time Left</div>
        </div>
    </div>

    <!-- Main Interview Container -->
    <div class="meet-container">
        <!-- Video Grid -->
        <div class="video-grid">
            <!-- AI Interviewer -->
            <div class="video-participant ai-interviewer">
                <div class="ai-avatar" id="aiAvatar">ðŸ¤–</div>
                <div class="participant-name">Alex - AI Interviewer</div>
            </div>

            <!-- User Video -->
            <div class="video-participant candidate">
                <video class="participant-video" id="userVideo" autoplay muted playsinline></video>
                <div class="participant-name">{{ candidate_name|default:"You" }}</div>
                <div id="recordingIndicator" style="position: absolute; top: 10px; left: 10px; background: #ea4335; color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; display: none; align-items: center; gap: 4px;">
                    <span style="width: 8px; height: 8px; background: white; border-radius: 50%; animation: blink 1s infinite;"></span>
                    REC
                </div>
            </div>
        </div>

        <!-- Subtitle Overlay -->
        <div class="subtitle-overlay" id="subtitleOverlay">
            <div class="subtitle-text" id="subtitleText" data-initial-text="{{ ai_question|default:"Hello! Welcome to your AI interview. Can you tell me about yourself and why you're interested in this position?" }}">
                <!-- Text will be populated by typewriter effect -->
            </div>
        </div>

        <!-- Meet Controls -->
        <div class="meet-controls">
            <button class="control-btn mic-active" id="muteBtn" title="Mute/Unmute">ðŸŽ¤</button>
            <button class="control-btn" id="cameraBtn" title="Camera">ðŸ“¹</button>
            <button class="control-btn end-btn" id="endBtn" title="End interview">ðŸ“ž</button>
        </div>
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completionModal">
        <div class="modal-content">
            <h3>Interview Complete! ðŸŽ‰</h3>
            <p>Thank you for taking the time to interview with us. We'll review your responses and get back to you within 2-3 business days.</p>
            <button class="btn-primary" onclick="window.location.href='{% url 'jobseeker_dashboard' %}'">
                Back to Dashboard
            </button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="aiAudioPlayer" style="display: none;"></audio>
    
    <!-- Interview Microphone Always-On System -->
    <script src="{% static 'js/interview-microphone-always-on.js' %}"></script>
    
    <!-- Typewriter Synchronization System -->
    <script src="{% static 'js/typewriter-sync.js' %}"></script>

    <!-- CSRF Token -->
    {% csrf_token %}

    <script>
        // Global variables
        let isMicOn = true;
        let currentQuestionCount = 1;
        let interviewTimer = null;
        let startTime = new Date();
        let totalTimeMinutes = {{ interview.interview_duration_minutes|default:"15" }}; // Interview duration from database
        
        // Get CSRF token
        function getCSRFToken() {
            return document.querySelector('[name=csrfmiddlewaretoken]').value;
        }

        // Camera and Recording Variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let isCameraOn = true;
        let userStream = null;

        // Initialize camera with recording
        async function initializeCamera() {
            try {
                userStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: true
                });
                
                const userVideo = document.getElementById('userVideo');
                userVideo.srcObject = userStream;
                console.log('Camera initialized successfully');
                
                // Setup recording
                setupRecording();
                
                // Setup camera button
                setupCameraButton();
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
            }
        }
        
        // Setup recording
        function setupRecording() {
            if (!userStream) return;
            
            try {
                mediaRecorder = new MediaRecorder(userStream, {
                    mimeType: 'video/webm'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    saveRecording();
                };
                
                // Auto-start recording
                setTimeout(() => {
                    startRecording();
                }, 2000);
                
            } catch (error) {
                console.error('Recording setup failed:', error);
            }
        }
        
        // Start recording
        function startRecording() {
            if (mediaRecorder && !isRecording) {
                recordedChunks = [];
                mediaRecorder.start(1000);
                isRecording = true;
                
                const indicator = document.getElementById('recordingIndicator');
                if (indicator) {
                    indicator.style.display = 'flex';
                }
                
                console.log('Recording started');
            }
        }
        
        // Stop recording
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                const indicator = document.getElementById('recordingIndicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }
                
                console.log('Recording stopped');
            }
        }
        
        // Save recording
        async function saveRecording() {
            if (recordedChunks.length === 0) return;
            
            try {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const formData = new FormData();
                
                const pathParts = window.location.pathname.split('/');
                const uuid = pathParts[pathParts.length - 2];
                
                formData.append('recording', blob, `interview-${uuid}.webm`);
                formData.append('interview_uuid', uuid);
                formData.append('duration', '300');
                
                const csrfToken = getCSRFToken();
                
                const response = await fetch('/save-interview-recording/', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrfToken },
                    body: formData
                });
                
                if (response.ok) {
                    console.log('Recording saved successfully');
                } else {
                    console.error('Failed to save recording');
                }
                
            } catch (error) {
                console.error('Error saving recording:', error);
            }
        }
        
        // Setup camera button
        function setupCameraButton() {
            const cameraBtn = document.getElementById('cameraBtn');
            if (!cameraBtn) return;
            
            cameraBtn.onclick = function() {
                toggleCamera();
            };
            
            updateCameraButton();
        }
        
        // Toggle camera
        function toggleCamera() {
            if (!userStream) return;
            
            const videoTracks = userStream.getVideoTracks();
            isCameraOn = !isCameraOn;
            
            videoTracks.forEach(track => {
                track.enabled = isCameraOn;
            });
            
            updateCameraButton();
            console.log(`Camera ${isCameraOn ? 'ON' : 'OFF'}`);
        }
        
        // Update camera button
        function updateCameraButton() {
            const cameraBtn = document.getElementById('cameraBtn');
            if (!cameraBtn) return;
            
            if (isCameraOn) {
                cameraBtn.style.background = '#5f6368';
                cameraBtn.title = 'Turn off camera';
            } else {
                cameraBtn.style.background = '#ea4335';
                cameraBtn.title = 'Turn on camera';
            }
        }

        // Update timer display
        function updateTimer() {
            const elapsedSeconds = Math.floor((new Date() - startTime) / 1000);
            const totalSeconds = totalTimeMinutes * 60;
            const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);
            
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (remainingSeconds <= 0) {
                clearInterval(interviewTimer);
                showCompletionModal();
            }
        }

        // Start timer
        function startTimer() {
            interviewTimer = setInterval(updateTimer, 1000);
        }

        // Toggle microphone (but keep it always on for interview)
        function toggleMicrophone() {
            // In interview mode, microphone should always stay on
            // Only toggle speech recognition
            if (isMicOn) {
                // Stop speech recognition but keep mic on
                speechRecognitionBlocked = true;
                stopSpeechRecognition();
                
                const muteBtn = document.getElementById('muteBtn');
                muteBtn.classList.remove('mic-active');
                muteBtn.classList.add('mic-muted');
                muteBtn.innerHTML = 'ðŸ”‡';
                muteBtn.title = 'Speech recognition disabled - Click to enable';
                
                console.log('ðŸ”‡ Speech recognition disabled (mic hardware stays on)');
            } else {
                // Re-enable speech recognition
                speechRecognitionBlocked = false;
                
                const muteBtn = document.getElementById('muteBtn');
                muteBtn.classList.add('mic-active');
                muteBtn.classList.remove('mic-muted');
                muteBtn.innerHTML = 'ðŸŽ¤';
                muteBtn.title = 'Speech recognition enabled - Always listening';
                
                // Start speech recognition if not blocked by AI
                if (!isAISpeaking) {
                    startSpeechRecognition();
                }
                
                console.log('ðŸŽ¤ Speech recognition enabled');
            }
            
            // Note: We don't actually disable the microphone hardware
            // The microphone stays on for the entire interview
            // We only control speech recognition
        }

        // Show completion modal
        function showCompletionModal() {
            // Stop recording before showing modal
            stopRecording();
            
            setTimeout(() => {
                document.getElementById('completionModal').classList.add('show');
            }, 1000);
        }

        // Ultra fast legacy typewriter - 25ms per character
        function typewriterEffect(element, text, duration, callback) {
            element.textContent = '';
            let index = 0;
            const typeInterval = setInterval(() => {
                if (index < text.length) {
                    element.textContent += text.charAt(index);
                    index++;
                } else {
                    clearInterval(typeInterval);
                    if (callback) callback();
                }
            }, 25); // 25ms per character = ultra fast
        }
        
        // Enhanced synchronized typewriter using new system
        function synchronizedTypewriter(element, text, audioElement, callback) {
            if (window.TypewriterSync) {
                window.TypewriterSync.createSynchronized(element, text, audioElement)
                    .then(() => {
                        if (callback) callback();
                    });
            } else {
                // Fallback to regular typewriter
                typewriterEffect(element, text, null, callback);
            }
        }
        
        // Handle AI response with improved typewriter sync
        function handleAIResponse(data) {
            // Update question counter
            currentQuestionCount = data.question_count || currentQuestionCount + 1;
            document.getElementById('questionCounter').textContent = `${currentQuestionCount}/8`;
            
            // Update progress bar
            const progress = (currentQuestionCount / 8) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
            
            // Block speech recognition while AI is speaking
            isAISpeaking = true;
            speechRecognitionBlocked = true;
            stopSpeechRecognition();
            
            console.log('ðŸ¤– AI is speaking - speech recognition blocked');
            
            // Show subtitle overlay
            const subtitleOverlay = document.getElementById('subtitleOverlay');
            subtitleOverlay.classList.add('show');
            
            // Start synchronized typewriter and audio
            if (data.audio && data.audio.trim() !== '') {
                playAIAudioWithSyncedTypewriter(data.audio, data.response, data.audio_duration);
            } else {
                // No audio, use natural typewriter timing
                const subtitleText = document.getElementById('subtitleText');
                typewriterEffect(subtitleText, data.response, null, () => {
                    setTimeout(() => {
                        handleAIFinishedSpeaking();
                    }, 1000);
                });
            }
            
            // Hide subtitles after appropriate time (faster due to instant typewriter)
            const hideDelay = data.audio_duration ? Math.max((data.audio_duration * 1000) + 2000, 4000) : 5000;
            setTimeout(() => {
                subtitleOverlay.classList.remove('show');
            }, hideDelay);
            
            // Check if interview is complete
            if (data.is_final || currentQuestionCount >= 8) {
                setTimeout(showCompletionModal, 2000);
            }
        }
        
        // Handle when AI finishes speaking
        function handleAIFinishedSpeaking() {
            isAISpeaking = false;
            
            // Wait a moment before re-enabling speech recognition
            setTimeout(() => {
                if (isMicOn && !speechRecognitionBlocked) {
                    speechRecognitionBlocked = false;
                    startSpeechRecognition();
                    console.log('ðŸŽ¤ AI finished speaking - speech recognition re-enabled');
                }
            }, 1000); // 1 second delay to ensure AI audio has fully stopped
        }
        
        // ULTRA FAST TYPEWRITER - No sync, just fast typing
        function playAIAudioWithSyncedTypewriter(audioUrl, text, audioDuration) {
            const audioPlayer = document.getElementById('aiAudioPlayer');
            const subtitleText = document.getElementById('subtitleText');
            
            subtitleText.textContent = '';
            
            console.log(`âš¡ ULTRA FAST: Starting immediate typewriter`);
            
            // ULTRA FAST TYPING - 25ms per character, no waiting
            let index = 0;
            const typeInterval = setInterval(() => {
                if (index < text.length) {
                    subtitleText.textContent += text.charAt(index);
                    index++;
                } else {
                    clearInterval(typeInterval);
                    console.log('âš¡ ULTRA FAST: Typewriter completed');
                }
            }, 25); // 25ms per character = very fast
            
            // Play audio separately (don't wait for it)
            if (audioUrl && audioUrl.trim() !== '') {
                audioPlayer.src = audioUrl;
                audioPlayer.load();
                audioPlayer.oncanplaythrough = () => {
                    audioPlayer.play().catch(console.error);
                };
                audioPlayer.onended = () => {
                    handleAIFinishedSpeaking();
                };
                audioPlayer.onerror = () => {
                    setTimeout(() => handleAIFinishedSpeaking(), 2000);
                };
            } else {
                setTimeout(() => handleAIFinishedSpeaking(), text.length * 25 + 1000);
            }
        }
        
        // Legacy function for compatibility
        function playAIAudio(audioUrl) {
            const audioPlayer = document.getElementById('aiAudioPlayer');
            
            if (audioUrl && audioUrl.trim() !== '') {
                audioPlayer.src = audioUrl;
                
                audioPlayer.onended = () => {
                    console.log('ðŸ”Š AI audio finished playing');
                    handleAIFinishedSpeaking();
                };
                
                audioPlayer.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    handleAIFinishedSpeaking();
                };
                
                audioPlayer.play().catch(error => {
                    console.error('Audio play failed:', error);
                    handleAIFinishedSpeaking();
                });
            } else {
                handleAIFinishedSpeaking();
            }
        }

        // Send response to backend
        async function sendResponse(text) {
            try {
                const response = await fetch(window.location.href, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': getCSRFToken(),
                    },
                    body: new URLSearchParams({ text: text })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    handleAIResponse(data);
                }
            } catch (error) {
                console.error('Error sending response:', error);
            }
        }

        // Speech recognition variables
        let recognition = null;
        let isListening = false;
        let isAISpeaking = false;
        let speechRecognitionBlocked = false;
        
        // Initialize speech recognition
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                recognition.continuous = true;
                recognition.maxAlternatives = 1;
                
                recognition.onstart = function() {
                    console.log('ðŸŽ¤ Speech recognition started');
                    isListening = true;
                };
                
                recognition.onend = function() {
                    console.log('ðŸŽ¤ Speech recognition ended');
                    isListening = false;
                    
                    // Auto-restart if not blocked and mic is on
                    if (isMicOn && !speechRecognitionBlocked && !isAISpeaking) {
                        setTimeout(() => {
                            if (isMicOn && !speechRecognitionBlocked && !isAISpeaking) {
                                startSpeechRecognition();
                            }
                        }, 500);
                    }
                };
                
                recognition.onresult = function(event) {
                    // Only process if not blocked by AI speech
                    if (!speechRecognitionBlocked && !isAISpeaking) {
                        const transcript = event.results[event.results.length - 1][0].transcript;
                        console.log('ðŸ—£ï¸ User said:', transcript);
                        sendResponse(transcript);
                    } else {
                        console.log('ðŸš« Speech recognition blocked - AI is speaking');
                    }
                };
                
                recognition.onerror = function(error) {
                    console.error('Speech recognition error:', error);
                    if (error.error === 'not-allowed') {
                        alert('Microphone permission denied. Please allow microphone access and refresh the page.');
                    }
                };
                
                // Start initial recognition
                if (isMicOn) {
                    startSpeechRecognition();
                }
            }
        }
        
        // Start speech recognition
        function startSpeechRecognition() {
            if (recognition && !isListening && isMicOn && !speechRecognitionBlocked && !isAISpeaking) {
                try {
                    recognition.start();
                } catch (e) {
                    console.log('Recognition already started or failed to start:', e);
                }
            }
        }
        
        // Stop speech recognition
        function stopSpeechRecognition() {
            if (recognition && isListening) {
                recognition.stop();
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize camera
            await initializeCamera();
            
            // Initialize speech recognition
            initializeSpeechRecognition();
            
            // Ensure microphone button shows correct initial state
            const muteBtn = document.getElementById('muteBtn');
            muteBtn.classList.add('mic-active');
            muteBtn.innerHTML = 'ðŸŽ¤';
            muteBtn.title = 'Speech recognition enabled - Always listening';
            
            // Start timer
            startTimer();
            
            // Show initial subtitle with synchronized typewriter effect
            setTimeout(() => {
                const subtitleOverlay = document.getElementById('subtitleOverlay');
                const subtitleText = document.getElementById('subtitleText');
                const initialText = subtitleText.getAttribute('data-initial-text') || subtitleText.textContent;
                
                subtitleOverlay.classList.add('show');
                
                // Clear text content for typewriter effect
                subtitleText.textContent = '';
                
                // Check if there's initial audio
                const initialAudio = `{{ audio_url|safe }}`;
                const serverDuration = {{ audio_duration|default:"null" }};
                
                if (initialAudio && initialAudio !== 'None' && initialAudio !== '' && initialAudio !== 'null') {
                    console.log('ðŸ”Š Setting up initial audio with synchronized typewriter');
                    
                    // Block speech recognition during initial question
                    isAISpeaking = true;
                    speechRecognitionBlocked = true;
                    
                    // Start synchronized audio and typewriter
                    playAIAudioWithSyncedTypewriter(initialAudio, initialText, serverDuration);
                } else {
                    console.log('ðŸ–Šï¸ No initial audio, using natural typewriter timing');
                    
                    // Block speech recognition during initial question
                    isAISpeaking = true;
                    speechRecognitionBlocked = true;
                    
                    // Ultra fast initial typing - no complex logic
                    let index = 0;
                    const typeInterval = setInterval(() => {
                        if (index < initialText.length) {
                            subtitleText.textContent += initialText.charAt(index);
                            index++;
                        } else {
                            clearInterval(typeInterval);
                            setTimeout(() => {
                                handleAIFinishedSpeaking();
                            }, 1000);
                        }
                    }, 25); // 25ms per character
                }
            }, 1000);
            
            // Hide initial subtitle after 6 seconds (faster due to quicker typing)
            setTimeout(() => {
                document.getElementById('subtitleOverlay').classList.remove('show');
            }, 7000);
        });

        // Button event listeners
        document.getElementById('muteBtn').addEventListener('click', () => {
            // Toggle speech recognition state (not actual microphone)
            isMicOn = !isMicOn;
            toggleMicrophone();
        });
        
        document.getElementById('endBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to end the interview?')) {
                showCompletionModal();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (interviewTimer) {
                clearInterval(interviewTimer);
            }
        });
    </script>
</body>
</html>
    </script>
</body>
</html>


